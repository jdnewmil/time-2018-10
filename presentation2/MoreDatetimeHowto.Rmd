---
title: "Other Datetime Approaches"
author: "Jeff Newmiller"
date: "September 9, 2018"
output: slidy_presentation
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = FALSE)
suppressPackageStartupMessages( library(zoo) )
```

## Other approaches to handling time

Some people think the `POSIXt` approach is too rigid, and try out their own ideas for handling time:

- `chron::chron`
    * Contributed package, behaves similar to Excel
    * Internally represented as days since origin date (1970-01-01), a floating point number, including the fractional part!
- `zoo::yrmon`
    * Cannot handle increments of less than one month
    * Internally represented as numeric years, a floating point number, always rounded to nearest 1/12 when displayed

## Detour: Floating Point Error

R FAQ 7.31[^1] warns against depending on exact results when using floating point fractions:

```{r}
x <- 0.3     # floating point is always approximate
0.6 == 2 * x # works
0.9 == 3 * x # but you cannot rely on it
```

## Detour: Floating Point Error

Why not equal?

```{r}
0.9 - 3 * x
```

Error in `0.3` has become three times larger, but error in `0.9` is about the same as it was in `0.3`.

This imprecision is not unique to R... this applies to all software that uses floating point numbers.

## Detour: Floating Point Error

It is best to use a date/time representation that uses non-fractional values for your application...

- `Date` if you never use time-of-day, or 
- `POSIXct` if your smallest precision is one second.  

If your smallest precision is less than one second, `POSIXt` may introduce rounding errors so it is best to minimize the amount of calculations performed with such timestamps.

## `chron`

- Very similar to Excel time (simple)

```{r,echo=TRUE}
library(chron)
dtm1 <- chron( dates. = c( "3/13/2016", "3/13/2016" )
             , times. = c( "01:00:00", "03:00:00" )
             )
dtm1  # automatically formatted for display
```

## `chron` Internal Representation

See what R is storing without the automatic formatting:

```{r}
unclass( dtm1 )
```

## `chron` Comparison

```{r}
dtm1[ 1 ] < dtm1[ 2 ]
diff( dtm1 )
```

## `chron` Spring Forward

- Does not understand timezones
- Plotting
    + base graphics doesn't display right
    + ggplot automatically converts to POSIXct in `GMT` timezone (To display right, set `TZ="GMT"` when working with `chron`)

```{r,fig.height=3,fig.width=6}
library(ggplot2)
dtms1 <- seq( dtm1[ 1 ], dtm1[ 2 ], times( "00:30:00" ) ); dtms1
```

## `chron` Spring Forward

```{r,fig.height=3,fig.width=6}
Sys.setenv( TZ = "GMT" )
qplot( seq_along( dtms1 ), dtms1 ) +
  chron::scale_y_chron( format="%m/%d/%y %H:%M" )
```

## `chron` Sequence Rounding

```{r}
dtm2a <- chron( "02/20/13", "00:00:00" )
dtm2b <- chron( "07/03/18", "15:30:00" ) # stop at 3:30pm
dtm2 <- seq( from=dtm2a, to=dtm2b, by=times( "00:15:00" ) )
tail( dtm2 ) # stops one value too soon
length( dtm2 )
```

## `POSIXct` Sequence Rounding

```{r}
Sys.setenv( TZ="GMT" ) # emulate chron behavior
dtm3a <- as.POSIXct( "02/20/13 00:00:00"
                   , format = "%m/%d/%y %H:%M:%S"
                   )
dtm3b <- as.POSIXct( "07/03/18 15:30:00"
                   , format = "%m/%d/%y %H:%M:%S" 
                   )
dtm3 <- seq( from = dtm3a
           , to = dtm3b
           , by = as.difftime( 15, units="mins" )
           )
tail( dtm3 )   # does include final value
length( dtm3 ) # one more than cron example
```

## `zoo` Package offers `yearmon`/`yrqtr` alternatives

- Intended for long series of monthly data (e.g. financial data)

```{r,echo=TRUE}
library(zoo)
dt1 <- as.yearmon( c( "2016-03", "2016-04" ) )
dt1  # automatically formatted for display
```

## `zoo` Internal Representation

See what R is storing without the automatic formatting:

```{r}
unclass( dt1 )
```

## `zoo` Comparison

```{r}
dt1[ 1 ] < dt1[ 2 ]
diff( dt1 ) # displayed nonsensically
```

## `zoo` Sequences

Typical to build floating point sequences, then convert to `yearmon` type:

```{r}
n <- 1416
f2a <- seq( 1900
          , 1900 + n/12
          , by = 1/12 # unsafe practice
          )
d2a <- as.yearmon( f2a ) # rounded when converted
tail( d2a ) #  internal round-to-month is very robust
f2b <- 1900 + seq( 0, n )/12 # safer way to handle fractions
d2b <- as.yearmon( f2b )
tail( d2b ) # no difference

```

```{r}
as.numeric( f2a[ length( f2a ) ] ) - as.numeric( f2b[ length( f2b ) ] )
```


---
[^1]: https://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f